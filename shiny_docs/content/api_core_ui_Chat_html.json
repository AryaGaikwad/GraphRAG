{
  "metadata": {
    "title": "ui.chat – Shiny for Python",
    "description": "",
    "url": "api/core/ui.Chat.html"
  },
  "content": [
    {
      "type": "ol",
      "items": [
        "Chat interface",
        "ui.Chat"
      ]
    },
    {
      "type": "h1",
      "text": "ui.Chat"
    },
    {
      "type": "code",
      "text": "ui.Chat(self, id, *, messages=(), on_error='auto', tokenizer=None)"
    },
    {
      "type": "p",
      "text": "Create a chat interface."
    },
    {
      "type": "p",
      "text": "A UI component for building conversational interfaces. With it, end users can submit messages, which will cause a .on_user_submit() callback to run. That callback gets passed the user input message, which can be used to generate a response. The response can then be appended to the chat using .append_message() or .append_message_stream()."
    },
    {
      "type": "p",
      "text": "Here's a rough outline for how to implement a Chat:"
    },
    {
      "type": "code",
      "text": "from shiny.express import ui\n\n# Create and display chat instance\nchat = ui.Chat(id=\"my_chat\")\nchat.ui()\n\n# Define a callback to run when the user submits a message\n@chat.on_user_submit\nasync def handle_user_input(user_input: str):\n    # Create a response message stream\n    response = await my_model.generate_response(user_input, stream=True)\n    # Append the response into the chat\n    await chat.append_message_stream(response)"
    },
    {
      "type": "p",
      "text": "In the outline above, my_model.generate_response() is a placeholder for the function that generates a response based on the chat's messages. This function will look different depending on the model you're using, but it will generally involve passing the messages to the model and getting a response back. Also, you'll typically have a choice to stream=True the response generation, and in that case, you'll use .append_message_stream() instead of .append_message() to append the response to the chat. Streaming is preferrable when available since it allows for more responsive and scalable chat interfaces."
    },
    {
      "type": "p",
      "text": "It is also highly recommended to use a package like chatlas to generate responses, especially when responses should be aware of the chat history, support tool calls, etc. See this article to learn more."
    },
    {
      "type": "h2",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "A unique identifier for the chat session. In Shiny Core, make sure this id matches a corresponding chat_ui call in the UI."
    },
    {
      "type": "p",
      "text": "A sequence of messages to display in the chat. Each message can be either a string or a dictionary with content and role keys. The content key should contain a string, and the role key can be “assistant” or “user”. Content strings are interpreted as markdown and rendered to HTML on the client. Content may also include specially formatted input suggestion links (see .append_message_stream() for more information)."
    },
    {
      "type": "p",
      "text": "How to handle errors that occur in response to user input. When \"unhandled\", the app will stop running when an error occurs. Otherwise, a notification is displayed to the user and the app continues to run. * \"auto\": Sanitize the error message if the app is set to sanitize errors, otherwise display the actual error message. * \"actual\": Display the actual error message to the user. * \"sanitize\": Sanitize the error message before displaying it to the user. * \"unhandled\": Do not display any error message to the user."
    },
    {
      "type": "p",
      "text": "The tokenizer to use for calculating token counts, which is required to impose token_limits in .messages(). If not provided, a default generic tokenizer is attempted to be loaded from the tokenizers library. A specific tokenizer may also be provided by following the TokenEncoding (tiktoken or tozenizers) protocol (e.g., tiktoken.encoding_for_model(\"gpt-4o\"))."
    },
    {
      "type": "h2",
      "text": "Examples"
    },
    {
      "type": "code",
      "text": "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 400\n\n## file: app.py\nfrom shiny import App, ui\n\napp_ui = ui.page_fillable(\n    ui.panel_title(\"Hello Shiny Chat\"),\n    ui.chat_ui(\"chat\"),\n    fillable_mobile=True,\n)\n\n# Create a welcome message\nwelcome = \"\"\"\nHi! This is a simple Shiny `Chat` UI. Enter a message below and I will\nsimply repeat it back to you. For more examples, see this\n[folder of examples](https://github.com/posit-dev/py-shiny/tree/main/shiny/templates/chat).\n\"\"\"\n\n\ndef server(input, output, session):\n    chat = ui.Chat(id=\"chat\", messages=[welcome])\n\n    # Define a callback to run when the user submits a message\n    @chat.on_user_submit\n    async def handle_user_input(user_input: str):\n        # Append a response to the chat\n        await chat.append_message(f\"You said: {user_input}\")\n\n\napp = App(app_ui, server)\n\n\n## file: _template.json\n{\n  \"type\": \"app\",\n  \"id\": \"chat-hello\",\n  \"title\": \"Hello Shiny Chat\",\n  \"next_steps\": [\n    \"Run the app with `shiny run app.py`.\"\n  ]\n}\n\n\n## file: requirements.txt\nshiny\n\n"
    },
    {
      "type": "h2",
      "text": "Attributes"
    },
    {
      "type": "h2",
      "text": "Methods"
    },
    {
      "type": "h3",
      "text": "append_message"
    },
    {
      "type": "code",
      "text": "ui.Chat.append_message(message, *, icon=None)"
    },
    {
      "type": "p",
      "text": "Append a message to the chat."
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "The message to append. A variety of message formats are supported including a string, a dictionary with content and role keys, or a relevant chat completion object from platforms like OpenAI, Anthropic, Ollama, and others. Content strings are interpreted as markdown and rendered to HTML on the client. Content may also include specially formatted input suggestion links (see note below)."
    },
    {
      "type": "p",
      "text": "An optional icon to display next to the message, currently only used for assistant messages. The icon can be any HTML element (e.g., an img tag) or a string of HTML."
    },
    {
      "type": "h4",
      "text": "Note"
    },
    {
      "type": "p",
      "text": "Input suggestions are special links that send text to the user input box when clicked (or accessed via keyboard). They can be created in the following ways:"
    },
    {
      "type": "ul",
      "items": [
        "<span class='suggestion'>Suggestion text</span>: An inline text link that places ‘Suggestion text’ in the user input box when clicked.",
        "<img data-suggestion='Suggestion text' src='image.jpg'>: An image link with the same functionality as above.",
        "<span data-suggestion='Suggestion text'>Actual text</span>: An inline text link that places ‘Suggestion text’ in the user input box when clicked."
      ]
    },
    {
      "type": "p",
      "text": "A suggestion can also be submitted automatically by doing one of the following:"
    },
    {
      "type": "ul",
      "items": [
        "Adding a submit CSS class or a data-suggestion-submit=\"true\" attribute to the suggestion element.",
        "Holding the Ctrl/Cmd key while clicking the suggestion link."
      ]
    },
    {
      "type": "p",
      "text": "Note that a user may also opt-out of submitting a suggestion by holding the Alt/Option key while clicking the suggestion link."
    },
    {
      "type": "p",
      "text": "Use .append_message_stream() instead of this method when stream=True (or similar) is specified in model’s completion method."
    },
    {
      "type": "h3",
      "text": "append_message_stream"
    },
    {
      "type": "code",
      "text": "ui.Chat.append_message_stream(message, *, icon=None)"
    },
    {
      "type": "p",
      "text": "Append a message as a stream of message chunks."
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "An (async) iterable of message chunks to append. A variety of message chunk formats are supported, including a string, a dictionary with content and role keys, or a relevant chat completion object from platforms like OpenAI, Anthropic, Ollama, and others. Content strings are interpreted as markdown and rendered to HTML on the client. Content may also include specially formatted input suggestion links (see note below)."
    },
    {
      "type": "p",
      "text": "An optional icon to display next to the message, currently only used for assistant messages. The icon can be any HTML element (e.g., an img tag) or a string of HTML."
    },
    {
      "type": "h4",
      "text": "Note"
    },
    {
      "type": "code",
      "text": "Input suggestions are special links that send text to the user input box when\nclicked (or accessed via keyboard). They can be created in the following ways:\n\n* `<span class='suggestion'>Suggestion text</span>`: An inline text link that\n    places 'Suggestion text' in the user input box when clicked.\n* `<img data-suggestion='Suggestion text' src='image.jpg'>`: An image link with\n    the same functionality as above.\n* `<span data-suggestion='Suggestion text'>Actual text</span>`: An inline text\n    link that places 'Suggestion text' in the user input box when clicked.\n\nA suggestion can also be submitted automatically by doing one of the following:\n\n* Adding a `submit` CSS class or a `data-suggestion-submit=\"true\"` attribute to\n  the suggestion element.\n* Holding the `Ctrl/Cmd` key while clicking the suggestion link.\n\nNote that a user may also opt-out of submitting a suggestion by holding the\n`Alt/Option` key while clicking the suggestion link."
    },
    {
      "type": "code",
      "text": "Use this method (over `.append_message()`) when `stream=True` (or similar) is\nspecified in model's completion method."
    },
    {
      "type": "h4",
      "text": "Returns"
    },
    {
      "type": "p",
      "text": "An extended task that represents the streaming task. The .result() method of the task can be called in a reactive context to get the final state of the stream."
    },
    {
      "type": "h3",
      "text": "clear_messages"
    },
    {
      "type": "code",
      "text": "ui.Chat.clear_messages()"
    },
    {
      "type": "p",
      "text": "Clear all chat messages."
    },
    {
      "type": "h3",
      "text": "destroy"
    },
    {
      "type": "code",
      "text": "ui.Chat.destroy()"
    },
    {
      "type": "p",
      "text": "Destroy the chat instance."
    },
    {
      "type": "h3",
      "text": "messages"
    },
    {
      "type": "code",
      "text": "ui.Chat.messages(\n    format=MISSING,\n    token_limits=None,\n    transform_user='all',\n    transform_assistant=False,\n)"
    },
    {
      "type": "p",
      "text": "Reactively read chat messages"
    },
    {
      "type": "p",
      "text": "Obtain chat messages within a reactive context. The default behavior is intended for passing messages along to a model for response generation where you typically want to:"
    },
    {
      "type": "ol",
      "items": [
        "Cap the number of tokens sent in a single request (i.e., token_limits).",
        "Apply user input transformations (i.e., transform_user), if any.",
        "Not apply assistant response transformations (i.e., transform_assistant) since these are predominantly for display purposes (i.e., the model shouldn't concern itself with how the responses are displayed)."
      ]
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "The message format to return. The default value of MISSING means chat messages are returned as ChatMessage objects (a dictionary with content and role keys). Other supported formats include: * \"anthropic\": Anthropic message format. * \"google\": Google message (aka content) format. * \"langchain\": LangChain message format. * \"openai\": OpenAI message format. * \"ollama\": Ollama message format."
    },
    {
      "type": "p",
      "text": "Limit the conversation history based on token limits. If specified, only the most recent messages that fit within the token limits are returned. This is useful for avoiding “exceeded token limit” errors when sending messages to the relevant model, while still providing the most recent context available. A specified value must be a tuple of two integers. The first integer is the maximum number of tokens that can be sent to the model in a single request. The second integer is the amount of tokens to reserve for the model’s response. Note that token counts based on the tokenizer provided to the Chat constructor."
    },
    {
      "type": "p",
      "text": "Whether to return user input messages with transformation applied. This only matters if a transform_user_input was provided to the chat constructor. The default value of \"all\" means all user input messages are transformed. The value of \"last\" means only the last user input message is transformed. The value of \"none\" means no user input messages are transformed."
    },
    {
      "type": "p",
      "text": "Whether to return assistant messages with transformation applied. This only matters if an transform_assistant_response was provided to the chat constructor."
    },
    {
      "type": "h4",
      "text": "Note"
    },
    {
      "type": "p",
      "text": "Messages are listed in the order they were added. As a result, when this method is called in a .on_user_submit() callback (as it most often is), the last message will be the most recent one submitted by the user."
    },
    {
      "type": "h4",
      "text": "Returns"
    },
    {
      "type": "p",
      "text": "A tuple of chat messages."
    },
    {
      "type": "h3",
      "text": "on_user_submit"
    },
    {
      "type": "code",
      "text": "ui.Chat.on_user_submit(fn=None)"
    },
    {
      "type": "p",
      "text": "Define a function to invoke when user input is submitted."
    },
    {
      "type": "p",
      "text": "Apply this method as a decorator to a function (fn) that should be invoked when the user submits a message. This function can take an optional argument, which will be the user input message."
    },
    {
      "type": "p",
      "text": "In many cases, the implementation of fn should also do the following:"
    },
    {
      "type": "ol",
      "items": [
        "Generate a response based on the user input."
      ]
    },
    {
      "type": "ul",
      "items": [
        "If the response should be aware of chat history, use a package like chatlas to manage the chat state, or use the .messages() method to get the chat history."
      ]
    },
    {
      "type": "ol",
      "items": [
        "Append that response to the chat component using .append_message() ( or .append_message_stream() if the response is streamed)."
      ]
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "A function to invoke when user input is submitted."
    },
    {
      "type": "h4",
      "text": "Note"
    },
    {
      "type": "p",
      "text": "This method creates a reactive effect that only gets invalidated when the user submits a message. Thus, the function fn can read other reactive dependencies, but it will only be re-invoked when the user submits a message."
    },
    {
      "type": "h3",
      "text": "set_user_message"
    },
    {
      "type": "code",
      "text": "ui.Chat.set_user_message(value)"
    },
    {
      "type": "p",
      "text": "Deprecated. Use update_user_input(value=value) instead."
    },
    {
      "type": "h3",
      "text": "transform_assistant_response"
    },
    {
      "type": "code",
      "text": "ui.Chat.transform_assistant_response(fn=None)"
    },
    {
      "type": "p",
      "text": "Transform assistant responses."
    },
    {
      "type": "p",
      "text": "Use this method as a decorator on a function (fn) that transforms assistant responses before displaying them in the chat. This is useful for post-processing model responses before displaying them to the user."
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "A function that takes a string and returns either a string, shiny.ui.HTML, or None. If fn returns a string, it gets interpreted and parsed as a markdown on the client (and the resulting HTML is then sanitized). If fn returns shiny.ui.HTML, it will be displayed as-is. If fn returns None, the response is effectively ignored."
    },
    {
      "type": "h4",
      "text": "Note"
    },
    {
      "type": "p",
      "text": "When doing an .append_message_stream(), fn gets called on every chunk of the response (thus, it should be performant), and can optionally access more information (i.e., arguments) about the stream. The 1st argument (required) contains the accumulated content, the 2nd argument (optional) contains the current chunk, and the 3rd argument (optional) is a boolean indicating whether this chunk is the last one in the stream."
    },
    {
      "type": "h3",
      "text": "transform_user_input"
    },
    {
      "type": "code",
      "text": "ui.Chat.transform_user_input(fn=None)"
    },
    {
      "type": "p",
      "text": "Transform user input."
    },
    {
      "type": "p",
      "text": "Use this method as a decorator on a function (fn) that transforms user input before storing it in the chat messages returned by .messages(). This is useful for implementing RAG workflows, like taking a URL and scraping it for text before sending it to the model."
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "A function to transform user input before storing it in the chat .messages(). If fn returns None, the user input is effectively ignored, and .on_user_submit() callbacks are suspended until more input is submitted. This behavior is often useful to catch and handle errors that occur during transformation. In this case, the transform function should append an error message to the chat (via .append_message()) to inform the user of the error."
    },
    {
      "type": "h3",
      "text": "update_user_input"
    },
    {
      "type": "code",
      "text": "ui.Chat.update_user_input(\n    value=None,\n    placeholder=None,\n    submit=False,\n    focus=False,\n)"
    },
    {
      "type": "p",
      "text": "Update the user input."
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "The value to set the user input to."
    },
    {
      "type": "p",
      "text": "The placeholder text for the user input."
    },
    {
      "type": "p",
      "text": "Whether to automatically submit the text for the user. Requires value."
    },
    {
      "type": "p",
      "text": "Whether to move focus to the input element. Requires value."
    },
    {
      "type": "h3",
      "text": "user_input"
    },
    {
      "type": "code",
      "text": "ui.Chat.user_input(transform=False)"
    },
    {
      "type": "p",
      "text": "Reactively read the user's message."
    },
    {
      "type": "h4",
      "text": "Parameters"
    },
    {
      "type": "p",
      "text": "Whether to apply the user input transformation function (if one was provided)."
    },
    {
      "type": "h4",
      "text": "Returns"
    },
    {
      "type": "p",
      "text": "The user input message (before any transformation)."
    },
    {
      "type": "h4",
      "text": "Note"
    },
    {
      "type": "p",
      "text": "Most users shouldn’t need to use this method directly since the last item in .messages() contains the most recent user input. It can be useful for:"
    },
    {
      "type": "ol",
      "items": [
        "Taking a reactive dependency on the user’s input outside of a .on_user_submit() callback.",
        "Maintaining message state separately from .messages()."
      ]
    }
  ],
  "code_examples": [
    "ui.Chat(self, id, *, messages=(), on_error='auto', tokenizer=None)",
    "ui.Chat(self, id, *, messages=(), on_error='auto', tokenizer=None)",
    "from shiny.express import ui\n\n# Create and display chat instance\nchat = ui.Chat(id=\"my_chat\")\nchat.ui()\n\n# Define a callback to run when the user submits a message\n@chat.on_user_submit\nasync def handle_user_input(user_input: str):\n    # Create a response message stream\n    response = await my_model.generate_response(user_input, stream=True)\n    # Append the response into the chat\n    await chat.append_message_stream(response)",
    "from shiny.express import ui\n\n# Create and display chat instance\nchat = ui.Chat(id=\"my_chat\")\nchat.ui()\n\n# Define a callback to run when the user submits a message\n@chat.on_user_submit\nasync def handle_user_input(user_input: str):\n    # Create a response message stream\n    response = await my_model.generate_response(user_input, stream=True)\n    # Append the response into the chat\n    await chat.append_message_stream(response)",
    "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 400\n\n## file: app.py\nfrom shiny import App, ui\n\napp_ui = ui.page_fillable(\n    ui.panel_title(\"Hello Shiny Chat\"),\n    ui.chat_ui(\"chat\"),\n    fillable_mobile=True,\n)\n\n# Create a welcome message\nwelcome = \"\"\"\nHi! This is a simple Shiny `Chat` UI. Enter a message below and I will\nsimply repeat it back to you. For more examples, see this\n[folder of examples](https://github.com/posit-dev/py-shiny/tree/main/shiny/templates/chat).\n\"\"\"\n\n\ndef server(input, output, session):\n    chat = ui.Chat(id=\"chat\", messages=[welcome])\n\n    # Define a callback to run when the user submits a message\n    @chat.on_user_submit\n    async def handle_user_input(user_input: str):\n        # Append a response to the chat\n        await chat.append_message(f\"You said: {user_input}\")\n\n\napp = App(app_ui, server)\n\n\n## file: _template.json\n{\n  \"type\": \"app\",\n  \"id\": \"chat-hello\",\n  \"title\": \"Hello Shiny Chat\",\n  \"next_steps\": [\n    \"Run the app with `shiny run app.py`.\"\n  ]\n}\n\n\n## file: requirements.txt\nshiny\n\n",
    "ui.Chat.append_message(message, *, icon=None)",
    "ui.Chat.append_message(message, *, icon=None)",
    "ui.Chat.append_message_stream(message, *, icon=None)",
    "ui.Chat.append_message_stream(message, *, icon=None)",
    "ui.Chat.clear_messages()",
    "ui.Chat.clear_messages()",
    "ui.Chat.destroy()",
    "ui.Chat.destroy()",
    "ui.Chat.messages(\n    format=MISSING,\n    token_limits=None,\n    transform_user='all',\n    transform_assistant=False,\n)",
    "ui.Chat.messages(\n    format=MISSING,\n    token_limits=None,\n    transform_user='all',\n    transform_assistant=False,\n)",
    "ui.Chat.on_user_submit(fn=None)",
    "ui.Chat.on_user_submit(fn=None)",
    "ui.Chat.set_user_message(value)",
    "ui.Chat.set_user_message(value)",
    "ui.Chat.transform_assistant_response(fn=None)",
    "ui.Chat.transform_assistant_response(fn=None)",
    "ui.Chat.transform_user_input(fn=None)",
    "ui.Chat.transform_user_input(fn=None)",
    "ui.Chat.update_user_input(\n    value=None,\n    placeholder=None,\n    submit=False,\n    focus=False,\n)",
    "ui.Chat.update_user_input(\n    value=None,\n    placeholder=None,\n    submit=False,\n    focus=False,\n)",
    "ui.Chat.user_input(transform=False)",
    "ui.Chat.user_input(transform=False)"
  ],
  "toc": [
    {
      "title": "ui.Chat",
      "url": "api/core/#shiny.ui.Chat"
    },
    {
      "title": "Parameters",
      "url": "api/core/#parameters"
    },
    {
      "title": "Examples",
      "url": "api/core/#examples"
    },
    {
      "title": "Attributes",
      "url": "api/core/#attributes"
    },
    {
      "title": "Methods",
      "url": "api/core/#methods"
    },
    {
      "title": "append_message",
      "url": "api/core/#shiny.ui.Chat.append_message"
    },
    {
      "title": "append_message_stream",
      "url": "api/core/#shiny.ui.Chat.append_message_stream"
    },
    {
      "title": "clear_messages",
      "url": "api/core/#shiny.ui.Chat.clear_messages"
    },
    {
      "title": "destroy",
      "url": "api/core/#shiny.ui.Chat.destroy"
    },
    {
      "title": "messages",
      "url": "api/core/#shiny.ui.Chat.messages"
    },
    {
      "title": "on_user_submit",
      "url": "api/core/#shiny.ui.Chat.on_user_submit"
    },
    {
      "title": "set_user_message",
      "url": "api/core/#shiny.ui.Chat.set_user_message"
    },
    {
      "title": "transform_assistant_response",
      "url": "api/core/#shiny.ui.Chat.transform_assistant_response"
    },
    {
      "title": "transform_user_input",
      "url": "api/core/#shiny.ui.Chat.transform_user_input"
    },
    {
      "title": "update_user_input",
      "url": "api/core/#shiny.ui.Chat.update_user_input"
    },
    {
      "title": "user_input",
      "url": "api/core/#shiny.ui.Chat.user_input"
    },
    {
      "title": "Shiny Core API",
      "url": "api/core/index.html"
    },
    {
      "title": "Page containers"
    },
    {
      "title": "ui.page_sidebar",
      "url": "api/core/ui.page_sidebar.html"
    },
    {
      "title": "ui.page_navbar",
      "url": "api/core/ui.page_navbar.html"
    },
    {
      "title": "ui.page_sidebar",
      "url": "api/core/ui.page_sidebar.html"
    },
    {
      "title": "ui.page_fillable",
      "url": "api/core/ui.page_fillable.html"
    },
    {
      "title": "ui.page_fluid",
      "url": "api/core/ui.page_fluid.html"
    },
    {
      "title": "ui.page_fixed",
      "url": "api/core/ui.page_fixed.html"
    },
    {
      "title": "ui.page_bootstrap",
      "url": "api/core/ui.page_bootstrap.html"
    },
    {
      "title": "ui.page_auto",
      "url": "api/core/ui.page_auto.html"
    },
    {
      "title": "ui.page_output",
      "url": "api/core/ui.page_output.html"
    },
    {
      "title": "UI Layouts"
    },
    {
      "title": "ui.sidebar",
      "url": "api/core/ui.sidebar.html"
    },
    {
      "title": "ui.layout_sidebar",
      "url": "api/core/ui.layout_sidebar.html"
    },
    {
      "title": "ui.layout_columns",
      "url": "api/core/ui.layout_columns.html"
    },
    {
      "title": "ui.layout_column_wrap",
      "url": "api/core/ui.layout_column_wrap.html"
    },
    {
      "title": "ui.card",
      "url": "api/core/ui.card.html"
    },
    {
      "title": "ui.card_header",
      "url": "api/core/ui.card_header.html"
    },
    {
      "title": "ui.card_footer",
      "url": "api/core/ui.card_footer.html"
    },
    {
      "title": "ui.popover",
      "url": "api/core/ui.popover.html"
    },
    {
      "title": "ui.tooltip",
      "url": "api/core/ui.tooltip.html"
    },
    {
      "title": "ui.accordion",
      "url": "api/core/ui.accordion.html"
    },
    {
      "title": "ui.accordion_panel",
      "url": "api/core/ui.accordion_panel.html"
    },
    {
      "title": "ui.column",
      "url": "api/core/ui.column.html"
    },
    {
      "title": "ui.row",
      "url": "api/core/ui.row.html"
    },
    {
      "title": "UI Inputs"
    },
    {
      "title": "ui.input_select",
      "url": "api/core/ui.input_select.html"
    },
    {
      "title": "ui.input_selectize",
      "url": "api/core/ui.input_selectize.html"
    },
    {
      "title": "ui.input_slider",
      "url": "api/core/ui.input_slider.html"
    },
    {
      "title": "ui.input_dark_mode",
      "url": "api/core/ui.input_dark_mode.html"
    },
    {
      "title": "ui.input_date",
      "url": "api/core/ui.input_date.html"
    },
    {
      "title": "ui.input_date_range",
      "url": "api/core/ui.input_date_range.html"
    },
    {
      "title": "ui.input_checkbox",
      "url": "api/core/ui.input_checkbox.html"
    },
    {
      "title": "ui.input_checkbox_group",
      "url": "api/core/ui.input_checkbox_group.html"
    },
    {
      "title": "ui.input_switch",
      "url": "api/core/ui.input_switch.html"
    },
    {
      "title": "ui.input_radio_buttons",
      "url": "api/core/ui.input_radio_buttons.html"
    },
    {
      "title": "ui.input_numeric",
      "url": "api/core/ui.input_numeric.html"
    },
    {
      "title": "ui.input_text",
      "url": "api/core/ui.input_text.html"
    },
    {
      "title": "ui.input_text_area",
      "url": "api/core/ui.input_text_area.html"
    },
    {
      "title": "ui.input_password",
      "url": "api/core/ui.input_password.html"
    },
    {
      "title": "ui.input_action_button",
      "url": "api/core/ui.input_action_button.html"
    },
    {
      "title": "ui.input_action_link",
      "url": "api/core/ui.input_action_link.html"
    },
    {
      "title": "ui.input_task_button",
      "url": "api/core/ui.input_task_button.html"
    },
    {
      "title": "Value boxes"
    },
    {
      "title": "ui.value_box",
      "url": "api/core/ui.value_box.html"
    },
    {
      "title": "ui.value_box_theme",
      "url": "api/core/ui.value_box_theme.html"
    },
    {
      "title": "ui.showcase_bottom",
      "url": "api/core/ui.showcase_bottom.html"
    },
    {
      "title": "ui.showcase_left_center",
      "url": "api/core/ui.showcase_left_center.html"
    },
    {
      "title": "ui.showcase_top_right",
      "url": "api/core/ui.showcase_top_right.html"
    },
    {
      "title": "Navigation (tab) panels"
    },
    {
      "title": "ui.nav_panel",
      "url": "api/core/ui.nav_panel.html"
    },
    {
      "title": "ui.nav_spacer",
      "url": "api/core/ui.nav_spacer.html"
    },
    {
      "title": "ui.nav_menu",
      "url": "api/core/ui.nav_menu.html"
    },
    {
      "title": "ui.nav_control",
      "url": "api/core/ui.nav_control.html"
    },
    {
      "title": "ui.navset_bar",
      "url": "api/core/ui.navset_bar.html"
    },
    {
      "title": "ui.navset_tab",
      "url": "api/core/ui.navset_tab.html"
    },
    {
      "title": "ui.navset_pill",
      "url": "api/core/ui.navset_pill.html"
    },
    {
      "title": "ui.navset_underline",
      "url": "api/core/ui.navset_underline.html"
    },
    {
      "title": "ui.navset_card_tab",
      "url": "api/core/ui.navset_card_tab.html"
    },
    {
      "title": "ui.navset_card_pill",
      "url": "api/core/ui.navset_card_pill.html"
    },
    {
      "title": "ui.navset_card_underline",
      "url": "api/core/ui.navset_card_underline.html"
    },
    {
      "title": "ui.navset_pill_list",
      "url": "api/core/ui.navset_pill_list.html"
    },
    {
      "title": "ui.navset_hidden",
      "url": "api/core/ui.navset_hidden.html"
    },
    {
      "title": "ui.navbar_options",
      "url": "api/core/ui.navbar_options.html"
    },
    {
      "title": "UI panels"
    },
    {
      "title": "ui.panel_absolute",
      "url": "api/core/ui.panel_absolute.html"
    },
    {
      "title": "ui.panel_fixed",
      "url": "api/core/ui.panel_fixed.html"
    },
    {
      "title": "ui.panel_conditional",
      "url": "api/core/ui.panel_conditional.html"
    },
    {
      "title": "ui.panel_title",
      "url": "api/core/ui.panel_title.html"
    },
    {
      "title": "ui.panel_well",
      "url": "api/core/ui.panel_well.html"
    },
    {
      "title": "Uploads & downloads"
    },
    {
      "title": "ui.input_file",
      "url": "api/core/ui.input_file.html"
    },
    {
      "title": "ui.download_button",
      "url": "api/core/ui.download_button.html"
    },
    {
      "title": "ui.download_link",
      "url": "api/core/ui.download_link.html"
    },
    {
      "title": "Chat interface"
    },
    {
      "title": "ui.Chat",
      "url": "api/core/ui.Chat.html"
    },
    {
      "title": "ui.chat_ui",
      "url": "api/core/ui.chat_ui.html"
    },
    {
      "title": "Streaming markdown"
    },
    {
      "title": "ui.MarkdownStream",
      "url": "api/core/ui.MarkdownStream.html"
    },
    {
      "title": "ui.output_markdown_stream",
      "url": "api/core/ui.output_markdown_stream.html"
    },
    {
      "title": "Custom UI"
    },
    {
      "title": "ui.Theme",
      "url": "api/core/ui.Theme.html"
    },
    {
      "title": "ui.HTML",
      "url": "api/core/ui.HTML.html"
    },
    {
      "title": "ui.TagList",
      "url": "api/core/ui.TagList.html"
    },
    {
      "title": "ui.tags",
      "url": "api/core/ui.tags.html"
    },
    {
      "title": "ui.markdown",
      "url": "api/core/ui.markdown.html"
    },
    {
      "title": "ui.include_css",
      "url": "api/core/ui.include_css.html"
    },
    {
      "title": "ui.include_js",
      "url": "api/core/ui.include_js.html"
    },
    {
      "title": "ui.insert_ui",
      "url": "api/core/ui.insert_ui.html"
    },
    {
      "title": "ui.remove_ui",
      "url": "api/core/ui.remove_ui.html"
    },
    {
      "title": "ui.busy_indicators.use",
      "url": "api/core/ui.busy_indicators.use.html"
    },
    {
      "title": "ui.busy_indicators.options",
      "url": "api/core/ui.busy_indicators.options.html"
    },
    {
      "title": "ui.fill.as_fillable_container",
      "url": "api/core/ui.fill.as_fillable_container.html"
    },
    {
      "title": "ui.fill.as_fill_item",
      "url": "api/core/ui.fill.as_fill_item.html"
    },
    {
      "title": "ui.fill.remove_all_fill",
      "url": "api/core/ui.fill.remove_all_fill.html"
    },
    {
      "title": "ui.css.as_css_unit",
      "url": "api/core/ui.css.as_css_unit.html"
    },
    {
      "title": "ui.css.as_css_padding",
      "url": "api/core/ui.css.as_css_padding.html"
    },
    {
      "title": "Update inputs"
    },
    {
      "title": "ui.update_select",
      "url": "api/core/ui.update_select.html"
    },
    {
      "title": "ui.update_selectize",
      "url": "api/core/ui.update_selectize.html"
    },
    {
      "title": "ui.update_slider",
      "url": "api/core/ui.update_slider.html"
    },
    {
      "title": "ui.update_dark_mode",
      "url": "api/core/ui.update_dark_mode.html"
    },
    {
      "title": "ui.update_date",
      "url": "api/core/ui.update_date.html"
    },
    {
      "title": "ui.update_date_range",
      "url": "api/core/ui.update_date_range.html"
    },
    {
      "title": "ui.update_checkbox",
      "url": "api/core/ui.update_checkbox.html"
    },
    {
      "title": "ui.update_checkbox_group",
      "url": "api/core/ui.update_checkbox_group.html"
    },
    {
      "title": "ui.update_switch",
      "url": "api/core/ui.update_switch.html"
    },
    {
      "title": "ui.update_radio_buttons",
      "url": "api/core/ui.update_radio_buttons.html"
    },
    {
      "title": "ui.update_numeric",
      "url": "api/core/ui.update_numeric.html"
    },
    {
      "title": "ui.update_text",
      "url": "api/core/ui.update_text.html"
    },
    {
      "title": "ui.update_text_area",
      "url": "api/core/ui.update_text_area.html"
    },
    {
      "title": "ui.update_navs",
      "url": "api/core/ui.update_navs.html"
    },
    {
      "title": "ui.update_action_button",
      "url": "api/core/ui.update_action_button.html"
    },
    {
      "title": "ui.update_action_link",
      "url": "api/core/ui.update_action_link.html"
    },
    {
      "title": "ui.update_task_button",
      "url": "api/core/ui.update_task_button.html"
    },
    {
      "title": "Update UI Layouts"
    },
    {
      "title": "ui.update_sidebar",
      "url": "api/core/ui.update_sidebar.html"
    },
    {
      "title": "ui.update_tooltip",
      "url": "api/core/ui.update_tooltip.html"
    },
    {
      "title": "ui.update_popover",
      "url": "api/core/ui.update_popover.html"
    },
    {
      "title": "ui.update_accordion",
      "url": "api/core/ui.update_accordion.html"
    },
    {
      "title": "ui.update_accordion_panel",
      "url": "api/core/ui.update_accordion_panel.html"
    },
    {
      "title": "ui.insert_accordion_panel",
      "url": "api/core/ui.insert_accordion_panel.html"
    },
    {
      "title": "ui.remove_accordion_panel",
      "url": "api/core/ui.remove_accordion_panel.html"
    },
    {
      "title": "Rendering outputs"
    },
    {
      "title": "ui.output_plot",
      "url": "api/core/ui.output_plot.html"
    },
    {
      "title": "ui.output_image",
      "url": "api/core/ui.output_image.html"
    },
    {
      "title": "ui.output_table",
      "url": "api/core/ui.output_table.html"
    },
    {
      "title": "ui.output_data_frame",
      "url": "api/core/ui.output_data_frame.html"
    },
    {
      "title": "ui.output_text",
      "url": "api/core/ui.output_text.html"
    },
    {
      "title": "ui.output_code",
      "url": "api/core/ui.output_code.html"
    },
    {
      "title": "ui.output_text_verbatim",
      "url": "api/core/ui.output_text_verbatim.html"
    },
    {
      "title": "ui.output_ui",
      "url": "api/core/ui.output_ui.html"
    },
    {
      "title": "render.plot",
      "url": "api/core/render.plot.html"
    },
    {
      "title": "render.image",
      "url": "api/core/render.image.html"
    },
    {
      "title": "render.table",
      "url": "api/core/render.table.html"
    },
    {
      "title": "render.text",
      "url": "api/core/render.text.html"
    },
    {
      "title": "render.code",
      "url": "api/core/render.code.html"
    },
    {
      "title": "render.ui",
      "url": "api/core/render.ui.html"
    },
    {
      "title": "render.express",
      "url": "api/core/render.express.html"
    },
    {
      "title": "render.download",
      "url": "api/core/render.download.html"
    },
    {
      "title": "render.data_frame",
      "url": "api/core/render.data_frame.html"
    },
    {
      "title": "render.DataGrid",
      "url": "api/core/render.DataGrid.html"
    },
    {
      "title": "render.DataTable",
      "url": "api/core/render.DataTable.html"
    },
    {
      "title": "Reactive programming"
    },
    {
      "title": "reactive.calc",
      "url": "api/core/reactive.calc.html"
    },
    {
      "title": "reactive.effect",
      "url": "api/core/reactive.effect.html"
    },
    {
      "title": "reactive.value",
      "url": "api/core/reactive.value.html"
    },
    {
      "title": "reactive.Calc",
      "url": "api/core/reactive.Calc.html"
    },
    {
      "title": "reactive.Effect",
      "url": "api/core/reactive.Effect.html"
    },
    {
      "title": "reactive.Value",
      "url": "api/core/reactive.Value.html"
    },
    {
      "title": "reactive.event",
      "url": "api/core/reactive.event.html"
    },
    {
      "title": "reactive.isolate",
      "url": "api/core/reactive.isolate.html"
    },
    {
      "title": "reactive.invalidate_later",
      "url": "api/core/reactive.invalidate_later.html"
    },
    {
      "title": "reactive.extended_task",
      "url": "api/core/reactive.extended_task.html"
    },
    {
      "title": "reactive.flush",
      "url": "api/core/reactive.flush.html"
    },
    {
      "title": "reactive.poll",
      "url": "api/core/reactive.poll.html"
    },
    {
      "title": "reactive.file_reader",
      "url": "api/core/reactive.file_reader.html"
    },
    {
      "title": "reactive.lock",
      "url": "api/core/reactive.lock.html"
    },
    {
      "title": "req",
      "url": "api/core/req.html"
    },
    {
      "title": "Create and run applications"
    },
    {
      "title": "run_app",
      "url": "api/core/run_app.html"
    },
    {
      "title": "App",
      "url": "api/core/App.html"
    },
    {
      "title": "Inputs",
      "url": "api/core/Inputs.html"
    },
    {
      "title": "Outputs",
      "url": "api/core/Outputs.html"
    },
    {
      "title": "Session",
      "url": "api/core/Session.html"
    },
    {
      "title": "Display messages"
    },
    {
      "title": "ui.help_text",
      "url": "api/core/ui.help_text.html"
    },
    {
      "title": "ui.notification_show",
      "url": "api/core/ui.notification_show.html"
    },
    {
      "title": "ui.notification_remove",
      "url": "api/core/ui.notification_remove.html"
    },
    {
      "title": "ui.modal",
      "url": "api/core/ui.modal.html"
    },
    {
      "title": "ui.modal_show",
      "url": "api/core/ui.modal_show.html"
    },
    {
      "title": "ui.modal_remove",
      "url": "api/core/ui.modal_remove.html"
    },
    {
      "title": "ui.modal_button",
      "url": "api/core/ui.modal_button.html"
    },
    {
      "title": "ui.Progress",
      "url": "api/core/ui.Progress.html"
    },
    {
      "title": "Modules"
    },
    {
      "title": "module.ui",
      "url": "api/core/module.ui.html"
    },
    {
      "title": "module.server",
      "url": "api/core/module.server.html"
    },
    {
      "title": "Developer facing tools"
    },
    {
      "title": "Session",
      "url": "api/core/Session.html"
    },
    {
      "title": "Create output renderers",
      "url": "api/core/Renderer.html"
    },
    {
      "title": "htmltools methods",
      "url": "api/core/Htmltools.html"
    },
    {
      "title": "ExtendedTask",
      "url": "api/core/ExtendedTask.html"
    },
    {
      "title": "Types"
    },
    {
      "title": "Miscellaneous types",
      "url": "api/core/MiscTypes.html"
    },
    {
      "title": "Tag types",
      "url": "api/core/TagTypes.html"
    },
    {
      "title": "Exception types",
      "url": "api/core/ExceptionTypes.html"
    },
    {
      "title": "Deprecated"
    },
    {
      "title": "render.transformer.output_transformer",
      "url": "api/core/render.transformer.output_transformer.html"
    },
    {
      "title": "render.transformer.resolve_value_fn",
      "url": "api/core/render.transformer.resolve_value_fn.html"
    },
    {
      "title": "Experimental"
    },
    {
      "title": "Card",
      "url": "api/core/ExCard.html"
    }
  ]
}